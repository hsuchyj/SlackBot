{"version":3,"sources":["../src/utils/DialogUtils.ts"],"names":[],"mappings":";;;;;;;;;;AACA,mCAAmC;AAEnC,+EAA+E;AAC/E,MAAM,OAAO,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;AAQpC,0BAAkC,GAAyB,EAAE,KAAqB;IAC9E,IAAI,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;IAC5B,OAAO,IAAI,OAAO,CAAkB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACpD,GAAG,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC,GAAQ,EAAE,OAAwB,EAAE,EAAE;YAC5D,IAAI,CAAC,GAAG,EAAE;gBACN,IAAI,MAAM,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC;gBACvC,IAAI,MAAM,EAAE;oBACP,OAAe,CAAC,OAAO,GAAG,MAAM,CAAC;oBAClC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE;wBACpC,OAAO,CAAC,OAAO,CAAC,CAAC;oBACrB,CAAC,CAAC,CAAC;iBACN;qBAAM;oBACH,OAAO,CAAC,OAAO,CAAC,CAAC;iBACpB;aACJ;iBAAM;gBACH,MAAM,CAAC,GAAG,CAAC,CAAC;aACf;QACL,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;AACP,CAAC;AAnBD,4CAmBC;AAAA,CAAC;AAEF,4BAAmC,KAAqB;IACpD,yCAAyC;IACzC,IAAI,SAAS,GAAI,KAAa,CAAC;IAC/B,IAAI,SAAS,CAAC,QAAQ,IAAI,SAAS,CAAC,QAAQ,CAAC,MAAM,EAAE;QACjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAChD,IAAI,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI;gBAC1B,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,YAAY;gBAC3C,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,EAChC;gBACI,OAAO,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;aACvC;SACJ;KACJ;IACD,OAAO,IAAI,CAAC;AAChB,CAAC;AAdD,gDAcC;AAED,8BAAqC,OAAyB;IAC1D,OAAO,CAAC,OAAO,CAAC,WAAW,IAAI,OAAO,CAAC,WAAW,CAAC,OAAO,IAAI,OAAO,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;AAClG,CAAC;AAFD,oDAEC;AAED,0EAA0E;AAC1E,4CAA4C;AAC5C,oBAA2B,GAAQ;IAC/B,IAAI,GAAG,EAAE;QACL,OAAO,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,CAAC,WAAW,KAAK,MAAM,CAAC;KACtE;IACD,OAAO,IAAI,CAAC;AAChB,CAAC;AALD,gCAKC;AAED,8DAA8D;AAC9D,cAAc;AACd,+CAA+C;AAC/C,iIAAiI;AACjI,4DAA4D;AAC5D,2GAA2G;AAC3G,kCAA+C,aAAoC,EAAE,OAAwB,EAAE,SAAiB;;QAC5H,IAAI,QAAQ,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;QAEnC,gBAAgB;QAChB,IAAI,OAAO,GAAoB;YAC3B,MAAM,EAAE,MAAM;YACd,2EAA2E;YAC3E,6EAA6E;YAC7E,sCAAsC;YACtC,GAAG,EAAE,OAAO,CAAE,QAAQ,CAAC,OAAe,CAAC,UAAU,EAAE,mBAAmB,CAAC;YACvE,IAAI,EAAE;gBACF,OAAO,EAAE,IAAI;gBACb,QAAQ,EAAE,QAAQ;gBAClB,WAAW,EAAE;oBACT,cAAc,EAAE,SAAS;iBAC5B;aACJ;YACD,IAAI,EAAE,IAAI;SACb,CAAC;QAEF,IAAI,QAAQ,GAAG,MAAM,0BAA0B,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QACxE,IAAI,QAAQ,IAAI,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;YAC3C,IAAI,OAAO,GAAG,yBAAyB,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAQ,CAAC;YAC3E,IAAI,OAAO,CAAC,IAAI,EAAE;gBACd,OAAO,OAAO,CAAC,IAAI,CAAC;aACvB;YACD,IAAI,OAAO,CAAC,aAAa,EAAE;gBACvB,OAAO,OAAO,CAAC,aAAa,CAAC;aAChC;YACD,OAAO,OAAO,CAAC;SAClB;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;SAChF;IACL,CAAC;CAAA;AAjCD,4DAiCC;AAED,gCAAgC;AAChC,oCAA0C,aAAoC,EAAE,OAA2B;;QACvG,mBAAmB;QACnB,MAAM,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QAE7C,kBAAkB;QAClB,OAAO,IAAI,OAAO,CAAM,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACxC,OAAO,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE;gBACrC,IAAI,GAAG,EAAE;oBACL,MAAM,CAAC,GAAG,CAAC,CAAC;iBACf;qBAAM;oBACH,IAAI,QAAQ,CAAC,UAAU,GAAG,GAAG,EAAE;wBAC3B,IAAI;4BACA,IAAI,MAAM,GAAG,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;4BAChE,OAAO,CAAC,MAAM,CAAC,CAAC;yBACnB;wBAAC,OAAO,CAAC,EAAE;4BACR,MAAM,CAAC,CAAC,YAAY,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;yBAC5D;qBACJ;yBAAM;wBACH,IAAI,GAAG,GAAG,cAAc,GAAG,OAAO,CAAC,GAAG,GAAG,aAAa,GAAG,QAAQ,CAAC,UAAU,GAAG,IAAI,GAAG,QAAQ,CAAC,aAAa,CAAC;wBAC7G,MAAM,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;qBAC1B;iBACJ;YACL,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACP,CAAC;CAAA;AAED,sCAAsC;AACtC,wBAAwB,aAAoC,EAAE,OAAwB;IAClF,OAAO,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACzC,+DAA+D;QAC9D,aAAqB,CAAC,cAAc,CAAC,CAAC,GAAQ,EAAE,KAAa,EAAE,EAAE;YAC9D,IAAI,GAAG,EAAE;gBACL,MAAM,CAAC,GAAG,CAAC,CAAC;aACf;iBAAM;gBACH,OAAO,CAAC,OAAO,GAAG;oBACd,eAAe,EAAE,SAAS,GAAG,KAAK;iBACrC,CAAC;gBACF,OAAO,EAAE,CAAC;aACb;QACL,CAAC,CAAC,CAAC;IACP,CAAC,CAAC,CAAC;AACP,CAAC;AAED,2DAA2D;AAC3D,mCAAmC,OAAsC,EAAE,QAAa;IACpF,IAAI,MAAM,qBACH,OAAO,IACV,YAAY,EAAE,EAAE,EAAE,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,EACpC,OAAO,EAAE,IAAI,GAChB,CAAC;IACF,IAAI,MAAM,CAAC,EAAE,EAAE;QACX,OAAO,MAAM,CAAC,EAAE,CAAC;KACpB;IACD,IAAI,QAAQ,CAAC,YAAY,CAAC,EAAE;QACxB,MAAM,CAAC,EAAE,GAAG,QAAQ,CAAC,YAAY,CAAC,CAAC;KACtC;IACD,OAAO,MAAM,CAAC;AAClB,CAAC;AAED,kCAAkC;AAClC,sBAA6B,KAAqB;IAC9C,IAAI,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;IACpC,IAAI,WAAW,EAAE;QACb,IAAI,WAAW,CAAC,cAAc,EAAE;YAC5B,OAAO,WAAW,CAAC,cAAc,CAAC;SACrC;aAAM,IAAI,WAAW,CAAC,OAAO,EAAE;YAC5B,OAAO,WAAW,CAAC,OAAO,CAAC,EAAE,CAAC;SACjC;KACJ;IAED,OAAO,EAAE,CAAC;AACd,CAAC;AAXD,oCAWC;AAED,+BAA+B;AAC/B,mBAA0B,KAAqB;IAC3C,IAAI,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;IACpC,IAAI,WAAW,EAAE;QACb,IAAI,WAAW,CAAC,IAAI,EAAE;YAClB,OAAO,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC;SAC9B;aAAM,IAAI,WAAW,CAAC,WAAW,EAAE;YAChC,OAAO,WAAW,CAAC,WAAW,CAAC;SAClC;KACJ;IACD,OAAO,EAAE,CAAC;AACd,CAAC;AAVD,8BAUC","file":"DialogUtils.js","sourcesContent":["import * as builder from \"botbuilder\";\nimport * as request from \"request\";\n\n// used this format due to how url-join is created and packaged in node_modules\nconst urlJoin = require(\"url-join\");\n\nexport interface MultiTriggerActionDialogEntry {\n    dialogId: string;\n    match: RegExp | RegExp[] | string | string[];\n    action: builder.IDialogWaterfallStep | builder.IDialogWaterfallStep[];\n}\n\nexport function loadSessionAsync (bot: builder.UniversalBot, event: builder.IEvent): Promise<builder.Session> {\n    let address = event.address;\n    return new Promise<builder.Session>((resolve, reject) => {\n        bot.loadSession(address, (err: any, session: builder.Session) => {\n            if (!err) {\n                let locale = getLocaleFromEvent(event);\n                if (locale) {\n                    (session as any)._locale = locale;\n                    session.localizer.load(locale, (err2) => {\n                        resolve(session);\n                    });\n                } else {\n                    resolve(session);\n                }\n            } else {\n                reject(err);\n            }\n        });\n    });\n};\n\nexport function getLocaleFromEvent(event: builder.IEvent): string {\n    // casting to keep away typescript errors\n    let currEvent = (event as any);\n    if (currEvent.entities && currEvent.entities.length) {\n        for (let i = 0; i < currEvent.entities.length; i++) {\n            if (currEvent.entities[i].type &&\n                currEvent.entities[i].type === \"clientInfo\" &&\n                currEvent.entities[i].locale)\n            {\n                return currEvent.entities[i].locale;\n            }\n        }\n    }\n    return null;\n}\n\nexport function isMessageFromChannel(message: builder.IMessage): boolean {\n    return (message.sourceEvent && message.sourceEvent.channel && message.sourceEvent.channel.id);\n}\n\n// simply checks to see if the incoming object is an empty object, i.e. {}\n// returns true on a null or undefined input\nexport function isEmptyObj(obj: any): boolean {\n    if (obj) {\n        return Object.keys(obj).length === 0 && obj.constructor === Object;\n    }\n    return true;\n}\n\n// Starts a new reply chain by posting a message to a channel.\n// Parameters:\n//      chatConnector: Chat connector instance.\n//      message: The message to post. The address in this message is ignored, and the message is posted to the specified channel.\n//      channelId: Id of the channel to post the message to.\n// Returns: A copy of \"message.address\", with the \"conversation\" property referring to the new reply chain.\nexport async function startReplyChainInChannel(chatConnector: builder.ChatConnector, message: builder.Message, channelId: string): Promise<builder.IChatConnectorAddress> {\n    let activity = message.toMessage();\n\n    // Build request\n    let options: request.Options = {\n        method: \"POST\",\n        // We use urlJoin to concatenate urls. url.resolve should not be used here,\n        // since it resolves urls as hrefs are resolved, which could result in losing\n        // the last fragment of the serviceUrl\n        url: urlJoin((activity.address as any).serviceUrl, \"/v3/conversations\"),\n        body: {\n            isGroup: true,\n            activity: activity,\n            channelData: {\n                teamsChannelId: channelId,\n            },\n        },\n        json: true,\n    };\n\n    let response = await sendRequestWithAccessToken(chatConnector, options);\n    if (response && response.hasOwnProperty(\"id\")) {\n        let address = createAddressFromResponse(activity.address, response) as any;\n        if (address.user) {\n            delete address.user;\n        }\n        if (address.correlationId) {\n            delete address.correlationId;\n        }\n        return address;\n    } else {\n        throw new Error(\"Failed to start reply chain: no conversation ID returned.\");\n    }\n}\n\n// Send an authenticated request\nasync function sendRequestWithAccessToken(chatConnector: builder.ChatConnector, options: request.UrlOptions): Promise<any> {\n    // Add access token\n    await addAccessToken(chatConnector, options);\n\n    // Execute request\n    return new Promise<any>((resolve, reject) => {\n        request(options, (err, response, body) => {\n            if (err) {\n                reject(err);\n            } else {\n                if (response.statusCode < 400) {\n                    try {\n                        let result = typeof body === \"string\" ? JSON.parse(body) : body;\n                        resolve(result);\n                    } catch (e) {\n                        reject(e instanceof Error ? e : new Error(e.toString()));\n                    }\n                } else {\n                    let txt = \"Request to '\" + options.url + \"' failed: [\" + response.statusCode + \"] \" + response.statusMessage;\n                    reject(new Error(txt));\n                }\n            }\n        });\n    });\n}\n\n// Add access token to request options\nfunction addAccessToken(chatConnector: builder.ChatConnector, options: request.Options): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n        // ChatConnector type definition doesn't include getAccessToken\n        (chatConnector as any).getAccessToken((err: any, token: string) => {\n            if (err) {\n                reject(err);\n            } else {\n                options.headers = {\n                    \"Authorization\": \"Bearer \" + token,\n                };\n                resolve();\n            }\n        });\n    });\n}\n\n// Create a copy of address with the data from the response\nfunction createAddressFromResponse(address: builder.IChatConnectorAddress, response: any): builder.IChatConnectorAddress {\n    let result = {\n        ...address,\n        conversation: { id: response[\"id\"] },\n        useAuth: true,\n    };\n    if (result.id) {\n        delete result.id;\n    }\n    if (response[\"activityId\"]) {\n        result.id = response[\"activityId\"];\n    }\n    return result;\n}\n\n// Get the channel id in the event\nexport function getChannelId(event: builder.IEvent): string {\n    let sourceEvent = event.sourceEvent;\n    if (sourceEvent) {\n        if (sourceEvent.teamsChannelId) {\n            return sourceEvent.teamsChannelId;\n        } else if (sourceEvent.channel) {\n            return sourceEvent.channel.id;\n        }\n    }\n\n    return \"\";\n}\n\n// Get the team id in the event\nexport function getTeamId(event: builder.IEvent): string {\n    let sourceEvent = event.sourceEvent;\n    if (sourceEvent) {\n        if (sourceEvent.team) {\n            return sourceEvent.team.id;\n        } else if (sourceEvent.teamsTeamId) {\n            return sourceEvent.teamsTeamId;\n        }\n    }\n    return \"\";\n}"],"sourceRoot":"/app/build"}